#include <stdio.h>

// 중
// 두 자연수 (M, N) 입력 => 입력받은 두 수 범위에 있는 소수 출력
// 1 <= M <= N <= 1,000,000 자연수

int main(void) 
{
    // 자연수 변수 선언
    int M, N;
    int a, b;

    // 자연수 변수 입력 받기
    // 1 <= M <= N <= 1,000,000 아닐 경우, 다시 입력 받기
    M = 0, N = 0;
    a = 0, b = 0;

    while (M < 1 || M > N || N > 1000000)
        scanf("%d %d", &M, &N);

    // for 문 이용
    printf("소수 \n");
    for (int i = M; i <= N; i++)
    {
        for (int j=2; j<i; j++)
        {
            if (i % j == 0)
            {
               a = i;
               continue;
            }
            else if (i % j != 0)
            {
               b = i;
               continue;
            }
        }
         if (a != b)
         {
            printf("%d \n", i);
         }
    }
}

/*
    < 피드백 >
    1. 정답 코드 for (int j = 2; j * j <= i; j++)
      => 합리적
      => 뜻: 절반 이하(예: 10이면 5)면 그 이후도 소수 판별 결과 동일해서 그 불필요한 계산 없앰
             = 절반까지만 돌려도 됨
   2. 처음부터 짝수 거르고 홀수만 가지고 소수 판별 시작
      => 별로: 합리적이지 않음 / 쓸 데 없음
         이유: 조건이 2개(짝수 판별, 홀수 중 소수 판별)가 됨
*/

    /*
    방향성 

    1) M 이상 N 이하의 모든 수를 한 번씩 변수 i에 넣기
       -> for 문 이용
       -> 변수 i를 M으로 초기화하여 M부터 값이 들어가게끔 설정
    2) 변수 i를 한 번씩 모두 2 ~ 1,000,000로 나누기
       -> for 문 이용
    3) 나누어 떨어지지 않으면 소수로 판정 및 바로 출력 후 \n
       -> if 문 이용
    
    */
    

/*
   1. 자연수 변수 입력 받을 때
      1) 프로그래밍 개론 교재 290쪽 참고
      2) 처음부터 잘못된 값을 M, N에 넣어서 M, N 조건 안 맞게끔 만듦
       M, N 조건에 안 맞으면 scanf 다시 받게 하는 while 문 조건에 바로 만족

   2. 소수 정의: 1과 자기 자신만을 약수로 깆는 자연수 [소인수분해되지 않는 수]

   3. for 문 작동 순서: 조건 검사 -> 블록 실행 -> 증감 진행 -> 조건 검사
      예: for(int a=1; a<=5; a++) => a=6일 때 for문 빠져나옴 = a에 6이 들어가 있음

   4. 중간 점검 (1) 
      실행 결과: 3 5 5 5 7 7 7 7 7 (3 7 대입)
      코드: 
      for (int i = M; i <= N; i++)
      {
         for (int j=2; j<=i; j++)
         {
            if (i % j != 0)
               printf("%d \n", i);
            else if (i % j == 0)
               break;
         }
      }
      실행 결과 이유 [소수가 여러번 반복되는 이유]: else if를 여러번 충족 => 만족하는 i 값 여러번 출력
      break 쓰는 이유: i 중에서 2 ~ 1000000 중 하나인 j로 나누어 떨어짐 = 소수 아님 

   5. 중간 점검 (2)
      실행 결과: 3 5 7 9 11 13 15 (3 16 대입) = 홀수 출력
      코드:
      for (int i = M; i <= N; i++)
      {
         for (int j=2; j<i; j++)
         {
            if (i % j == 0)
               break;
            else if (i % j != 0) 
            {
               printf("%d \n", i);
               break;
            }
        }    
      }
      실행 결과 이유 [9 (15) 출력 이유]: i=9, j-2일 때 else if 조건 성립 => i(9) 출력
      문제점: else if 조건 성립한다고 바로 출력하면 안 됨 = 나머지 j도 전부 else if 성립하는지 확인 필요
*/